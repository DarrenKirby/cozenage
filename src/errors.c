/*
 * 'src/errors.c'
 * This file is part of Cozenage - https://github.com/DarrenKirby/cozenage
 * Copyright Â© 2025 Darren Kirby <darren@dragonbyte.ca>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "errors.h"
#include "cell.h"
#include "repr.h"
#include "types.h"

#include <gc/gc.h>


/* (error-object? obj)
 * Returns true if its argument is a CELL_ERROR object, else false. */
Cell* builtin_error_object(const Lex* e, const Cell* a)
{
    (void)e;
    Cell* err = CHECK_ARITY_EXACT(a, 1, "error-object?");
    if (err) return err;

    if (a->cell[0]->type == CELL_ERROR) {
        return True_Obj;
    }
    return False_Obj;
}


/* (raise string)
 * (raise string k)
 * (raise string k obj)
 * Returns an error object with message set to string. An optional integer argument denotes the type of error. The error
 * types are enumerated in src/cell.h, but for reference:
 *
 * GEN_ERR =    0; A general, non-specific error.
 * FILE_ERR =   1; An error whilst opening or closing a file.
 * READ_ERR =   2; An error reading from a file or stream.
 * SYNTAX_ERR = 3; A syntax error, these are generally only generated by the parser.
 * ARITY_ERR =  4; Wrong number of arguments to a procedure.
 * TYPE_ERR =   5; Procedure received an object of the wrong type.
 * INDEX_ERR =  6; Out of bounds index for compound type.
 * VALUE_ERR =  7; The arg is the correct type, but an invalid value of that type.
 *
 * If not specified, the default is 0 (GEN_ERROR). An optional third argument is the 'irritant', which is an object that
 * caused the error. Passing this value will result in the object's REPL representation being appended to the error
 * string. */
Cell* builtin_raise(const Lex* e, const Cell* a) {
    (void)e;
    Cell* err = CHECK_ARITY_RANGE(a, 1, 3, "raise");
    if (err) return err;

    if (a->cell[0]->type != CELL_STRING) {
        return make_cell_error(
            "raise: arg must be string",
            TYPE_ERR);
    }
    if (a->count == 1) {
        return make_cell_error(a->cell[0]->str, GEN_ERR);
    }
    if (a->count > 1) {
        if (a->cell[1]->type != CELL_INTEGER) {
            return make_cell_error(
                "raise: error type arg must be an integer",
                TYPE_ERR);
        }

        const uint8_t err_no = a->cell[1]->integer_v;
        if (err_no > 7) {
            return make_cell_error(
                "raise: invalid error type value",
                VALUE_ERR);
        }

        if (a->count == 2) {
            return make_cell_error(a->cell[0]->str, err_no);
        }
        return make_cell_error(
            fmt_err("%s: %s", a->cell[0]->str,
                cell_to_string(a->cell[2], MODE_REPL)), err_no);
    }
    return make_cell_error("raise: invalid argument", TYPE_ERR);
}


/* This is obviously not really related to errors,
 * but I wanted a procedure that prints a report from
 * libgc... */

void gc_print_report(void)
{
    const size_t heap_size        = GC_get_heap_size();
    const size_t free_bytes       = GC_get_free_bytes();
    const size_t unmapped_bytes   = GC_get_unmapped_bytes();
    const size_t bytes_since_gc   = GC_get_bytes_since_gc();
    const size_t total_bytes      = GC_get_total_bytes();
    const unsigned long gc_count  = GC_get_gc_no();

    const size_t used_bytes = heap_size - free_bytes;

    printf("===== GC Report ==========================\n");
    printf("Heap size:           %zu bytes (%.2f MB)\n",
           heap_size, (double)heap_size / (1024.0 * 1024.0));
    printf("Used bytes:          %zu bytes (%.2f MB)\n",
           used_bytes, (double)used_bytes / (1024.0 * 1024.0));
    printf("Free bytes:          %zu bytes (%.2f MB)\n",
           free_bytes, (double)free_bytes / (1024.0 * 1024.0));
    printf("Unmapped bytes:      %zu bytes (%.2f MB)\n",
           unmapped_bytes, (double)unmapped_bytes / (1024.0 * 1024.0));
    printf("Bytes since last GC: %zu bytes\n", bytes_since_gc);
    printf("Total bytes allocd:  %zu bytes (lifetime)\n", total_bytes);
    printf("GC collections:      %lu\n", gc_count);

#ifdef GC_ENABLE_INCREMENTAL
    printf("Incremental GC:      %s\n",
           GC_is_incremental_mode() ? "enabled" : "disabled");
#endif

    printf("==========================================\n");
}

Cell* builtin_gc_report(const Lex* e, const Cell* a) {
    (void)e;
    (void)a;
    printf("Before collection:\n");
    gc_print_report();
    /* Force a collection */
    GC_gcollect();
    printf("After collection:\n");
    gc_print_report();
    return USP_Obj;
}
